---
title: Shell 常用命令学习
data: 2019-1-16  
categories: Research
tags:
   - Bash
   - Shell
---
Git Bash 中可执行Shell 脚本的命令  Bash 类似编译器作用 全称  'Bourne-Again SHell'
Shell 可以看成是编程语言。这里是对个人使用的一些命令及相应语句的记录。
<!-- more -->

<u>ls  -la</u> 显示当前文件夹的内容 或者 <u>ls -la [文件名]</u> 显示指定文件信息
<u>echo</u> 命令用于向窗口输出文本
<u>cat  [文件名]</u>  显示文件中的内容
<u>chmod +x  ./[文件名]</u>  使得<u>./[文件名]</u>具有 执行权限
[命令or脚本or可执行程序]<<tag   将脚本内开始标记tag 和结束标记tag 之间的内容作为输入
<u>./abc.exe</u>  执行 abc.exe 可执行程序
sed命令
<u>sed -i "1c hi"  text.dat</u>  # 将文件名为test.dat的第一行替代为hi, 多行如何替换？
我的第一个循环脚本

```shell
for ((i=1;i<=10;i++)) # 执行10次
do
	# 变量赋值时,变量名与变量之间不能存在空格,引用变量:${变量名}
	line2_name="OPEN/CLOSE K_field_0.1_${i}X.dat  1 (FREE) 1" 
	sed -i "6c ${line2_name}" NGTT.bcf
	line1_name="DATA(BINARY) 63 NGTT_${i}.BGT"
	sed -i "23c ${line1_name}" NaturalGradientTraceTest.nam
	# 执行 mf96.exe 并输入 NaturalGradientTraceTest.nam
	./mf96.exe NaturalGradientTraceTest.nam
done
```
<u>touch "文件名"</u>  #创建文件
<u>rm -if "文件名"</u>   #删除文件
<u>command1 | command2</u> 这里的“|” 是把第一个命令的执行结果作为第二个命令的输入
<u>sed -n 23p rw3d.dat | awk -F " " '{print $3}'</u> 这里是读取文件rw3d.dat 中的第23行，第三列内容，列以空格分开
<u>awk 'NR==23 {print $3}' rw3d.dat</u> 与上一行命令的作用一致

第二个循环脚本

```shell
for ((i=1;i<=500;i++)) # 执行500次
do
	# 变量名与变量之间不能存在空格
	line1_name="NGTT_${i}.BGT   1.0  1 	 2 " 
	sed -i "34c ${line1_name}" rw3d_example.inp
	sed -i "35c ${line1_name}" rw3d_example.inp
	sed -i "36c ${line1_name}" rw3d_example.inp
	line2_name="rw3d_cart_spat_mom_${i}.dat"
	line3_name="rw3d_temp_mom_${i}.dat"
	line4_name="rw3d_plane_dispersivity_${i}.dat"
	sed -i "8c ${line2_name}" rw3d.nam
	sed -i "13c ${line3_name}" rw3d.nam
	sed -i "14c ${line4_name}" rw3d.nam
	./RW3D_Sep_29.exe
done
```
第三个循环脚本
'>'  ’文件名‘ 是 覆盖原文件内容的输出 '>>' 是在原文件内容上追加。如果文件不存在的话，会直接创建
变量写入文件时 <u>echo ${变量名}   ${变量名2} >> 文件名</u> 一定要有echo

```shell
for ((i=1;i<=500;i++))
do
	# sed -n 23p rw3d.dat | awk -F " " '{print $3}' # 不够简单
	# 命令执行后的结果赋给变量时 要用 $(命令行) 格式
	Line=$(awk 'NR==5 {print $3}' rw3d_plane_dispersivity_${i}.dat) 
	#echo ${Line}
	echo ${i}  ${Line} >> dis.dat
done
```



